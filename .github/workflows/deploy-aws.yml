name: Deploy to AWS EC2

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script: |
            # Install required dependencies if not present
            if ! command -v git &> /dev/null; then
              echo "Installing git..."
              sudo yum update -y
              sudo yum install -y git
            fi

            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo yum update -y
              sudo yum install -y docker
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker ec2-user
              
              # Install docker-compose plugin
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo curl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
              
              # Also install standalone docker-compose for compatibility
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            # Navigate to application directory
            mkdir -p ~/insforge
            cd ~/insforge

            # Pull latest code or fresh clone
            if [ -d ".git" ]; then
              # Clean up old branches and reset to latest
              git remote prune origin
              git fetch --all --prune
              # Use the branch that triggered the workflow
              git checkout ${{ github.ref_name }} || git checkout main || git checkout master
              git reset --hard origin/${{ github.ref_name }} || git reset --hard origin/main || git reset --hard origin/master
            else
              # Remove existing non-git directory if it exists
              if [ -d ~/insforge ] && [ ! -d ~/insforge/.git ]; then
                rm -rf ~/insforge/*
                rm -rf ~/insforge/.*
              fi
              # Clone using SSH (since we set up SSH key)
              git clone git@github.com:InsForge/insforge.git ~/insforge
              cd ~/insforge
              # Stay on default branch instead of detached HEAD
              # git checkout ${{ github.sha }}  # Commented out to avoid detached HEAD
            fi

            # Create .env file matching .env.example structure
            cat > .env << EOF
            # Server Configuration
            PORT=7130
            
            # PostgreSQL Configuration
            POSTGRES_USER=postgres
            POSTGRES_PASSWORD=postgres
            POSTGRES_DB=insforge
            
            API_BASE_URL=http://localhost:7130
            VITE_API_BASE_URL=http://localhost:7130
            
            # Authentication
            JWT_SECRET=your-secret-jwt-key-must-be-32-characters-minimum
            ADMIN_EMAIL=admin@example.com
            ADMIN_PASSWORD=change-this-password
            
            # Logflare
            LOGFLARE_PUBLIC_ACCESS_TOKEN=your-super-secret-and-long-logflare-key-public
            LOGFLARE_PRIVATE_ACCESS_TOKEN=your-super-secret-and-long-logflare-key-private
            
            # Docker
            DOCKER_SOCKET_LOCATION=/var/run/docker.sock
            
            EOF

            # Ensure we're in the right directory with docker-compose.yml
            cd ~/insforge
            
            # Stop ALL containers regardless of which compose file started them
            # This ensures clean slate even if previous deploy used different compose file
            sudo docker stop $(sudo docker ps -aq) || true
            sudo docker rm $(sudo docker ps -aq) || true
            
            # Also try to stop using both compose files (in case either was used)
            # IMPORTANT: Specify -f for dev file too, to avoid default file selection
            sudo /usr/local/bin/docker-compose -f docker-compose.yml down -v || true
            sudo /usr/local/bin/docker-compose -f docker-compose.prod.yml down -v || true
            
            # Clean up any orphaned volumes and networks
            sudo docker volume prune -f || true
            sudo docker network prune -f || true
            
            # Build fresh image with no cache and latest base images
            sudo /usr/local/bin/docker-compose -f docker-compose.prod.yml build --no-cache --pull
            
            # Now start fresh with production compose
            sudo /usr/local/bin/docker-compose -f docker-compose.prod.yml up -d

            # Clean up old images
            sudo docker image prune -af

            # Check deployment status
            sleep 10
            sudo /usr/local/bin/docker-compose -f docker-compose.prod.yml ps
            sudo /usr/local/bin/docker-compose -f docker-compose.prod.yml logs --tail=50