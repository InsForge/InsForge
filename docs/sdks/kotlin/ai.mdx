---
title: AI SDK Reference
description: AI chat completions, web search, file parsing, and image generation with the InsForge Kotlin SDK
---

import KotlinSdkInstallation from '/snippets/kotlin-sdk-installation.mdx';

## Installation

<KotlinSdkInstallation />

---

## listModels()

List all available AI models.

### Example

```kotlin
val models = client.ai.listModels()

models.forEach { model ->
    println("${model.provider}/${model.modelId}")
    println("  Input: ${model.inputModality}, Output: ${model.outputModality}")
    println("  Max tokens: ${model.maxTokens}")
}
```

---

## chatCompletion()

Create an AI chat completion.

### Parameters

- `model` (String) - Model identifier (e.g., "anthropic/claude-3.5-haiku", "openai/gpt-4o")
- `messages` (`List<ChatMessage>`) - Conversation messages
- `temperature` (Double?, optional) - Sampling temperature (0.0-2.0)
- `maxTokens` (Int?, optional) - Maximum tokens to generate
- `systemPrompt` (String?, optional) - System prompt
- `webSearch` (WebSearchPlugin?, optional) - Enable web search capabilities
- `fileParser` (FileParserPlugin?, optional) - Enable file/PDF parsing

### Returns

```kotlin
ChatCompletionResponse
```

### Example (Basic)

```kotlin
val response = client.ai.chatCompletion(
    model = "anthropic/claude-3.5-haiku",
    messages = listOf(
        ChatMessage.user("What is the capital of France?")
    )
)

println(response.text)  // Direct access to text content
println("Tokens used: ${response.metadata.usage.totalTokens}")

// Access annotations if available
response.annotations?.forEach { annotation ->
    println("Citation: ${annotation.urlCitation.url}")
}
```

### Multimodal Messages

The SDK supports multimodal messages with images, PDFs, and audio.

```kotlin
// Simple text message (backward compatible)
val response = client.ai.chatCompletion(
    model = "openai/gpt-4",
    messages = listOf(ChatMessage.user("Hello!"))
)

// Custom multimodal message with multiple content parts
val customMessage = ChatMessage.multimodal(
    "user",
    TextContent(text = "Describe these images"),
    ImageContent(imageUrl = ImageUrlConfig(url = "https://example.com/1.jpg")),
    ImageContent(imageUrl = ImageUrlConfig(url = "https://example.com/2.jpg"))
)

val response = client.ai.chatCompletion(
    model = "anthropic/claude-sonnet-4.5",
    messages = listOf(customMessage)
)
```

### Example (With Parameters)

```kotlin
val response = client.ai.chatCompletion(
    model = "openai/gpt-4",
    messages = listOf(
        ChatMessage.system("You are a helpful assistant."),
        ChatMessage.user("Explain quantum computing in simple terms")
    ),
    temperature = 0.7,
    maxTokens = 1000
)

println(response.text)
```

### Example (Multi-turn Conversation)

```kotlin
val conversationHistory = mutableListOf<ChatMessage>()

// First message
conversationHistory.add(ChatMessage.user("What is Kotlin?"))

val response1 = client.ai.chatCompletion(
    model = "anthropic/claude-3.5-haiku",
    messages = conversationHistory
)

conversationHistory.add(ChatMessage.assistant(response1.text))

// Follow-up
conversationHistory.add(ChatMessage.user("What are its main features?"))

val response2 = client.ai.chatCompletion(
    model = "anthropic/claude-3.5-haiku",
    messages = conversationHistory
)

println(response2.text)
```

### Example (With Web Search)

```kotlin
val response = client.ai.chatCompletion(
    model = "openai/gpt-4",
    messages = listOf(
        ChatMessage.user("What are the latest news about AI?")
    ),
    webSearch = WebSearchPlugin(
        enabled = true,
        maxResults = 5,
        engine = WebSearchEngine.NATIVE
    )
)

println(response.text)

// Access URL citations from search results
response.annotations?.forEach { annotation ->
    println("Source: ${annotation.urlCitation.title} - ${annotation.urlCitation.url}")
}
```

### Example (With PDF Parsing)

```kotlin
// Using the convenience method
val response = client.ai.chatCompletionWithFile(
    model = "anthropic/claude-sonnet-4.5",
    text = "Summarize the content of this PDF",
    filename = "document.pdf",
    fileData = "https://example.com/document.pdf",
    pdfEngine = PdfEngine.MISTRAL_OCR
)

println(response.text)

// Or using custom multimodal message
val pdfMessage = ChatMessage.multimodal(
    "user",
    TextContent(text = "Summarize this document"),
    FileContent(
        file = FileConfig(
            filename = "document.pdf",
            fileData = "https://example.com/document.pdf"
        )
    )
)

val response2 = client.ai.chatCompletion(
    model = "anthropic/claude-sonnet-4.5",
    messages = listOf(pdfMessage),
    fileParser = FileParserPlugin(
        enabled = true,
        pdf = PdfParserConfig(engine = PdfEngine.MISTRAL_OCR)
    )
)

println(response2.text)
```

### Example (With Extended Reasoning)

```kotlin
val response = client.ai.chatCompletion(
    model = "anthropic/claude-sonnet-4.5",
    messages = listOf(
        ChatMessage.user("Solve this complex math problem step by step...")
    ),
    thinking = true
)

println(response.text)
```

### Example (Combined Features)

```kotlin
val response = client.ai.chatCompletion(
    model = "openai/gpt-4o",
    messages = messages,
    webSearch = WebSearchPlugin(enabled = true, maxResults = 3),
    fileParser = FileParserPlugin(enabled = true),
    thinking = true
)

println(response.text)
```

---

## chatCompletionWithImages()

Convenience method for chat completion with image analysis.

### Parameters

- `model` (String) - Model identifier (must support vision, e.g., "openai/gpt-4-vision")
- `text` (String) - Text prompt to accompany the images
- `imageUrls` (List\<String\>) - List of image URLs to analyze
- `temperature` (Double?, optional) - Sampling temperature
- `maxTokens` (Int?, optional) - Maximum tokens to generate

### Example

```kotlin
val response = client.ai.chatCompletionWithImages(
    model = "openai/gpt-4o",
    text = "What is in this image?",
    imageUrls = listOf("https://example.com/image.jpg")
)

println(response.text)
```

---

## chatCompletionWithFile()

Convenience method for chat completion with file (PDF) analysis.

### Parameters

- `model` (String) - Model identifier
- `text` (String) - Text prompt to accompany the file
- `filename` (String) - Name of the file (e.g., "report.pdf")
- `fileData` (String) - File URL or base64-encoded data URL
- `pdfEngine` (PdfEngine?, optional) - PDF processing engine
- `temperature` (Double?, optional) - Sampling temperature
- `maxTokens` (Int?, optional) - Maximum tokens to generate

### Example (Base64 Encoded)

```kotlin
// Load PDF from local file
val pdfBytes = File("document.pdf").readBytes()
val base64Data = "data:application/pdf;base64,${Base64.encodeToString(pdfBytes, Base64.NO_WRAP)}"

val response = client.ai.chatCompletionWithFile(
    model = "anthropic/claude-sonnet-4.5",
    text = "What are the key points in this document?",
    filename = "document.pdf",
    fileData = base64Data
)

println(response.text)
```

---

## chatCompletionWithWebSearch()

Convenience method for chat completion with web search enabled.

### Parameters

- `model` (String) - Model identifier
- `messages` (`List<ChatMessage>`) - Conversation messages
- `maxResults` (Int?, optional) - Maximum search results (default: 5)
- `engine` (WebSearchEngine?, optional) - Search engine to use
- `temperature` (Double?, optional) - Sampling temperature
- `maxTokens` (Int?, optional) - Maximum tokens to generate

### Example

```kotlin
val response = client.ai.chatCompletionWithWebSearch(
    model = "openai/gpt-4o",
    messages = listOf(
        ChatMessage(role = "user", content = "What are today's top news headlines?")
    ),
    maxResults = 5
)

println(response.text)

// Access citations
response.annotations?.forEach { annotation ->
    println("- ${annotation.urlCitation.title}: ${annotation.urlCitation.url}")
}
```

---

## chatCompletionStream()

Create a streaming chat completion. Returns `Flow<String>` that emits content chunks directly.

### Parameters

- `model` (String) - Model identifier
- `messages` (`List<ChatMessage>`) - Conversation messages
- `temperature` (Double?, optional) - Sampling temperature
- `maxTokens` (Int?, optional) - Maximum tokens to generate
- `webSearch` (WebSearchPlugin?, optional) - Enable web search capabilities
- `fileParser` (FileParserPlugin?, optional) - Enable file/PDF parsing
- `thinking` (Boolean?, optional) - Enable extended reasoning mode

### Example

```kotlin
client.ai.chatCompletionStream(
    model = "anthropic/claude-3.5-haiku",
    messages = listOf(
        ChatMessage(role = "user", content = "Tell me a story")
    )
).collect { content ->
    print(content)  // Content string directly
}
```

### Example (With StringBuilder)

```kotlin
val fullResponse = StringBuilder()

client.ai.chatCompletionStream(
    model = "openai/gpt-4o",
    messages = listOf(
        ChatMessage(role = "user", content = "Explain quantum computing")
    ),
    temperature = 0.7
).collect { content ->
    fullResponse.append(content)
    // Update UI with each chunk
    updateUI(fullResponse.toString())
}

println("Complete response: $fullResponse")
```

### Example (Streaming with Web Search)

```kotlin
client.ai.chatCompletionStream(
    model = "openai/gpt-4o",
    messages = listOf(
        ChatMessage(role = "user", content = "What's happening in tech news today?")
    ),
    webSearch = WebSearchPlugin(enabled = true, maxResults = 3)
).collect { content ->
    print(content)
}
```

---

## generateEmbeddings()

Generate vector embeddings for text input using AI models.

### Parameters

- `model` (String) - Embedding model identifier (e.g., "google/gemini-embedding-001")
- `input` (String?, optional) - Single text input to embed
- `inputs` (List\<String\>?, optional) - Multiple text inputs to embed
- `encodingFormat` (EmbeddingEncodingFormat?, optional) - Output format (FLOAT or BASE64)
- `dimensions` (Int?, optional) - Number of dimensions for the output embeddings

### Returns

```kotlin
EmbeddingsResponse
```

### Example (Single Text)

```kotlin
val response = client.ai.generateEmbeddings(
    model = "google/gemini-embedding-001",
    input = "Hello world"
)

println("Generated ${response.data.size} embedding(s)")
println("Dimensions: ${response.data.first().embedding.size}")
println("Model: ${response.metadata?.model}")
```

### Example (Multiple Texts)

```kotlin
val response = client.ai.generateEmbeddings(
    model = "google/gemini-embedding-001",
    inputs = listOf("Hello", "World", "How are you?")
)

response.data.forEachIndexed { index, embedding ->
    println("Embedding $index: ${embedding.embedding.take(5)}...")  // First 5 dimensions
}
```

### Example (With Optional Parameters)

```kotlin
val response = client.ai.generateEmbeddings(
    model = "google/gemini-embedding-001",
    input = "Hello world",
    encodingFormat = EmbeddingEncodingFormat.FLOAT,
    dimensions = 512
)

println("Embedding dimensions: ${response.data.first().embedding.size}")  // 512
```

### Example (Semantic Search)

```kotlin
// Generate embeddings for documents
val documents = listOf(
    "Kotlin is a modern programming language",
    "Android development with Jetpack Compose",
    "Machine learning with TensorFlow"
)

val docEmbeddings = client.ai.generateEmbeddings(
    model = "google/gemini-embedding-001",
    inputs = documents
)

// Generate embedding for query
val queryEmbedding = client.ai.generateEmbeddings(
    model = "google/gemini-embedding-001",
    input = "mobile app development"
)

// Calculate cosine similarity (simplified)
fun cosineSimilarity(a: List<Double>, b: List<Double>): Double {
    val dotProduct = a.zip(b).sumOf { it.first * it.second }
    val normA = sqrt(a.sumOf { it * it })
    val normB = sqrt(b.sumOf { it * it })
    return dotProduct / (normA * normB)
}

// Find most similar document
val queryVector = queryEmbedding.data.first().embedding
val similarities = docEmbeddings.data.mapIndexed { index, embedding ->
    index to cosineSimilarity(queryVector, embedding.embedding)
}

val mostSimilar = similarities.maxByOrNull { it.second }
println("Most similar: ${documents[mostSimilar!!.first]}")
```

---

## generateImage()

Generate images using AI models.

### Parameters

- `model` (String) - Image generation model (e.g., "openai/dall-e-3")
- `prompt` (String) - Image description

### Returns

```kotlin
ImageGenerationResponse
```

### Example

```kotlin
val response = client.ai.generateImage(
    model = "google/gemini-2.5-flash-image-preview",
    prompt = "A serene mountain landscape at sunset"
)

println("Generated ${response.count} image(s)")

response.images.forEach { image ->
    val imageUrl = image.imageUrl.url

    if (imageUrl.startsWith("data:image")) {
        // Handle base64 encoded image
        val base64Data = imageUrl.substringAfter("base64,")
        val imageData = Base64.decode(base64Data, Base64.DEFAULT)
        val bitmap = BitmapFactory.decodeByteArray(imageData, 0, imageData.size)
        imageView.setImageBitmap(bitmap)
    } else {
        // Handle URL - load with Coil/Glide
        // AsyncImage(model = imageUrl, ...)
    }
}
```

### Example (Save to Storage)

```kotlin
val response = client.ai.generateImage(
    model = "google/gemini-2.5-flash-image-preview",
    prompt = "A futuristic city skyline"
)

response.images.firstOrNull()?.let { image ->
    val imageUrl = image.imageUrl.url

    if (imageUrl.startsWith("data:image")) {
        val base64Data = imageUrl.substringAfter("base64,")
        val imageData = Base64.decode(base64Data, Base64.DEFAULT)

        // Upload to storage
        val uploadResult = client.storage
            .from("ai-images")
            .uploadWithAutoKey("generated.png", imageData) {
                contentType = "image/png"
            }

        // Save reference to database
        client.database
            .from("generated_images")
            .insertTyped(listOf(
                GeneratedImageRecord(
                    prompt = "A futuristic city skyline",
                    imageUrl = uploadResult.url
                )
            ))
            .returning()
            .execute<GeneratedImageRecord>()

        Log.d("AI", "Image saved: ${uploadResult.url}")
    }
}
```

---

## Jetpack Compose Integration

### Chat Screen

```kotlin
@Composable
fun ChatScreen() {
    var messages by remember { mutableStateOf<List<ChatMessage>>(emptyList()) }
    var inputText by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    Column(modifier = Modifier.fillMaxSize()) {
        LazyColumn(
            modifier = Modifier
                .weight(1f)
                .padding(16.dp),
            reverseLayout = true
        ) {
            items(messages.reversed()) { message ->
                ChatBubble(message = message)
            }
        }

        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            OutlinedTextField(
                value = inputText,
                onValueChange = { inputText = it },
                modifier = Modifier.weight(1f),
                placeholder = { Text("Message") }
            )

            Spacer(modifier = Modifier.width(8.dp))

            IconButton(
                onClick = {
                    if (inputText.isNotBlank() && !isLoading) {
                        val userMessage = ChatMessage(role = "user", content = inputText)
                        messages = messages + userMessage
                        val currentInput = inputText
                        inputText = ""

                        scope.launch {
                            isLoading = true
                            try {
                                val response = client.ai.chatCompletion(
                                    model = "anthropic/claude-3.5-haiku",
                                    messages = messages
                                )
                                messages = messages + ChatMessage(
                                    role = "assistant",
                                    content = response.text
                                )
                            } catch (e: Exception) {
                                Log.e("Chat", "Error: ${e.message}")
                            } finally {
                                isLoading = false
                            }
                        }
                    }
                },
                enabled = inputText.isNotBlank() && !isLoading
            ) {
                Icon(Icons.Default.Send, "Send")
            }
        }
    }
}

@Composable
fun ChatBubble(message: ChatMessage) {
    val isUser = message.role == "user"

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = if (isUser) Arrangement.End else Arrangement.Start
    ) {
        Card(
            colors = CardDefaults.cardColors(
                containerColor = if (isUser)
                    MaterialTheme.colorScheme.primary
                else
                    MaterialTheme.colorScheme.surfaceVariant
            )
        ) {
            Text(
                text = message.content,
                modifier = Modifier.padding(12.dp),
                color = if (isUser)
                    MaterialTheme.colorScheme.onPrimary
                else
                    MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}
```

### Streaming Chat

```kotlin
@Composable
fun StreamingChatScreen() {
    var response by remember { mutableStateOf("") }
    var isStreaming by remember { mutableStateOf(false) }
    var prompt by remember { mutableStateOf("") }
    val scope = rememberCoroutineScope()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        OutlinedTextField(
            value = prompt,
            onValueChange = { prompt = it },
            label = { Text("Your question") },
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(16.dp))

        Button(
            onClick = {
                scope.launch {
                    isStreaming = true
                    response = ""

                    try {
                        client.ai.chatCompletionStream(
                            model = "anthropic/claude-3.5-haiku",
                            messages = listOf(
                                ChatMessage(role = "user", content = prompt)
                            )
                        ).collect { content ->
                            response += content
                        }
                    } catch (e: Exception) {
                        Log.e("Stream", "Error: ${e.message}")
                    } finally {
                        isStreaming = false
                    }
                }
            },
            enabled = prompt.isNotBlank() && !isStreaming,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text(if (isStreaming) "Streaming..." else "Ask AI")
        }

        Spacer(modifier = Modifier.height(16.dp))

        Text(
            text = response,
            modifier = Modifier
                .weight(1f)
                .verticalScroll(rememberScrollState())
        )
    }
}
```

### Image Generation Screen

```kotlin
@Composable
fun ImageGenerationScreen() {
    var prompt by remember { mutableStateOf("") }
    var generatedBitmap by remember { mutableStateOf<Bitmap?>(null) }
    var isGenerating by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        OutlinedTextField(
            value = prompt,
            onValueChange = { prompt = it },
            label = { Text("Describe your image...") },
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(16.dp))

        Button(
            onClick = {
                scope.launch {
                    isGenerating = true
                    try {
                        val response = client.ai.generateImage(
                            model = "google/gemini-2.5-flash-image-preview",
                            prompt = prompt
                        )

                        response.images.firstOrNull()?.let { image ->
                            val imageUrl = image.imageUrl.url

                            if (imageUrl.startsWith("data:image")) {
                                val base64Data = imageUrl.substringAfter("base64,")
                                val data = Base64.decode(base64Data, Base64.DEFAULT)
                                generatedBitmap = BitmapFactory.decodeByteArray(
                                    data, 0, data.size
                                )
                            }
                        }
                    } catch (e: Exception) {
                        Log.e("ImageGen", "Failed: ${e.message}")
                    } finally {
                        isGenerating = false
                    }
                }
            },
            enabled = prompt.isNotBlank() && !isGenerating,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text(if (isGenerating) "Generating..." else "Generate Image")
        }

        Spacer(modifier = Modifier.height(16.dp))

        if (isGenerating) {
            CircularProgressIndicator()
        }

        generatedBitmap?.let { bitmap ->
            Image(
                bitmap = bitmap.asImageBitmap(),
                contentDescription = "Generated image",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(300.dp)
            )
        }
    }
}
```

---

## Error Handling

```kotlin
import dev.insforge.exceptions.InsforgeHttpException
import dev.insforge.exceptions.InsforgeException

try {
    val response = client.ai.chatCompletion(
        model = "anthropic/claude-3.5-haiku",
        messages = listOf(ChatMessage(role = "user", content = "Hello"))
    )
    println(response.text)
} catch (e: InsforgeHttpException) {
    when (e.error) {
        "MODEL_NOT_FOUND" -> println("Model not available")
        "RATE_LIMIT_EXCEEDED" -> println("Rate limit exceeded, try again later")
        "INVALID_REQUEST" -> println("Invalid request: ${e.message}")
        else -> println("API Error: ${e.message}")
    }
} catch (e: InsforgeException) {
    println("SDK Error: ${e.message}")
}
```

---

## Models Reference

### Enums

```kotlin
// Search engine options for web search
enum class WebSearchEngine {
    @SerialName("native") NATIVE,
    @SerialName("exa") EXA
}

// PDF processing engine options
enum class PdfEngine {
    @SerialName("pdf-text") PDF_TEXT,
    @SerialName("mistral-ocr") MISTRAL_OCR,
    @SerialName("native") NATIVE
}
```

### Plugin Configuration

```kotlin
// Web search plugin configuration
@Serializable
data class WebSearchPlugin(
    val enabled: Boolean = true,
    @SerialName("max_results") val maxResults: Int? = null,
    val engine: WebSearchEngine? = null
)

// PDF parser configuration
@Serializable
data class PdfParserConfig(
    val engine: PdfEngine? = null
)

// File parser plugin configuration
@Serializable
data class FileParserPlugin(
    val enabled: Boolean = true,
    val pdf: PdfParserConfig? = null
)
```

### ChatMessage

```kotlin
@Serializable
data class ChatMessage(
    val role: String,  // "user", "assistant", "system"
    val content: MessageContent  // String or List<ContentPart>
) {
    companion object {
        // Create a simple text message
        fun user(content: String): ChatMessage
        fun assistant(content: String): ChatMessage
        fun system(content: String): ChatMessage

        // Create a multimodal message with multiple content parts
        fun multimodal(role: String, vararg parts: ContentPart): ChatMessage
    }
}

// Content can be simple text or multimodal parts
@Serializable
sealed class MessageContent {
    @Serializable
    data class Text(val value: String) : MessageContent()

    @Serializable
    data class Parts(val parts: List<ContentPart>) : MessageContent()
}
```

### Content Parts (Multimodal)

```kotlin
// Base sealed class for content parts
@Serializable
sealed class ContentPart

// Text content
@Serializable
data class TextContent(
    val type: String = "text",
    val text: String
) : ContentPart()

// Image content
@Serializable
data class ImageContent(
    val type: String = "image_url",
    @SerialName("image_url") val imageUrl: ImageUrlConfig
) : ContentPart()

@Serializable
data class ImageUrlConfig(
    val url: String,
    val detail: ImageDetail? = null  // "auto", "low", "high"
)

@Serializable
enum class ImageDetail {
    @SerialName("auto") AUTO,
    @SerialName("low") LOW,
    @SerialName("high") HIGH
}

// File content (for PDFs and documents)
@Serializable
data class FileContent(
    val type: String = "file",
    val file: FileConfig
) : ContentPart()

@Serializable
data class FileConfig(
    val filename: String,
    @SerialName("file_data") val fileData: String  // URL or base64 data URL
)

// Audio content
@Serializable
data class AudioContent(
    val type: String = "input_audio",
    @SerialName("input_audio") val inputAudio: AudioConfig
) : ContentPart()

@Serializable
data class AudioConfig(
    val data: String,  // Base64 encoded audio
    val format: AudioFormat  // "wav", "mp3", etc.
)

@Serializable
enum class AudioFormat {
    @SerialName("wav") WAV,
    @SerialName("mp3") MP3,
    @SerialName("aiff") AIFF,
    @SerialName("aac") AAC,
    @SerialName("ogg") OGG,
    @SerialName("flac") FLAC,
    @SerialName("m4a") M4A
}
```

### ChatCompletionResponse

```kotlin
@Serializable
data class ChatCompletionResponse(
    val success: Boolean,
    val text: String,
    val annotations: List<UrlCitationAnnotation>? = null,
    val metadata: CompletionMetadata
)

@Serializable
data class CompletionMetadata(
    val model: String,
    val usage: TokenUsage
)

@Serializable
data class TokenUsage(
    @SerialName("prompt_tokens") val promptTokens: Int,
    @SerialName("completion_tokens") val completionTokens: Int,
    @SerialName("total_tokens") val totalTokens: Int
)
```

### Annotations

```kotlin
// URL citation information from web search results
@Serializable
data class UrlCitation(
    val url: String,
    val title: String? = null,
    @SerialName("start_index") val startIndex: Int? = null,
    @SerialName("end_index") val endIndex: Int? = null
)

// Annotation containing URL citation
@Serializable
data class UrlCitationAnnotation(
    val type: String,  // "url_citation"
    @SerialName("url_citation") val urlCitation: UrlCitation
)
```

### EmbeddingsResponse

```kotlin
// Encoding format options for embeddings
enum class EmbeddingEncodingFormat {
    @SerialName("float") FLOAT,
    @SerialName("base64") BASE64
}

@Serializable
data class EmbeddingsResponse(
    val `object`: String,  // "list"
    val data: List\<EmbeddingObject\>,
    val metadata: EmbeddingsMetadata? = null
)

@Serializable
data class EmbeddingObject(
    val `object`: String,  // "embedding"
    val embedding: List\<Double\>,  // or String for base64 format
    val index: Int
)

@Serializable
data class EmbeddingsMetadata(
    val model: String,
    val usage: EmbeddingsUsage? = null
)

@Serializable
data class EmbeddingsUsage(
    @SerialName("prompt_tokens") val promptTokens: Int? = null,
    @SerialName("total_tokens") val totalTokens: Int? = null
)
```

### ImageGenerationResponse

```kotlin
@Serializable
data class ImageGenerationResponse(
    val model: String,
    val images: List<GeneratedImage>,
    val text: String? = null,
    val count: Int,
    val metadata: ImageMetadata,
    val nextActions: String
)

@Serializable
data class GeneratedImage(
    val type: String,  // "image_url"
    @SerialName("image_url") val imageUrl: ImageUrl
)

@Serializable
data class ImageUrl(
    val url: String  // URL or data:image/... base64
)

@Serializable
data class ImageMetadata(
    val model: String,
    val provider: String
)
```

### AIModel

```kotlin
@Serializable
data class AIModel(
    val id: String,
    val provider: String,
    val modelId: String,
    val inputModality: String,  // "text", "image", etc.
    val outputModality: String,
    val maxTokens: Int? = null
)
```
